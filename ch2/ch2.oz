%宣言的計算モデル

% 計算モデル
% 計算モデルとは形式的体型であって一つの言語を定義し，かつその言語の命令が抽象マシンによってどのように実行されるかを定義するものである．

% 計算モデルの言語でプログラムを書くのに使うプログラミング技法と設計原則の集合である
% これをプログラミングモデルという

% プログラムが正しく振る舞うという確信を深め，プログラムの効率を算定するために，プログラムについて推論することを可能にする推論技法の集合である．

% 2.1 実用的プログラミング言語についての定義
% 2.1.1 言語の構文

% 拡張バッカスナウア記法

% 文脈自由文法と文脈依存文法

% あいまい性

% 2.1.2 言語の意味

% 2.2 単一代入格納域

% 2.2.3 値生成

% 2.2.4 変数識別子

% 変数識別子から格納域実態への写像を環境という

% 2.2.6 部分値
% 部分値とは束縛されていない変数を含んでいるかもしれないデータ構造

% 2.2.7 変数の変数への束縛

% 2.2.8 データフロー変数
% この本の実行モデルでは，未束縛の変数を使おうとすると，変数が束縛されるまで待つという方法を取る．
% このような宣言的変数をデータフローという
% 並列プログラミングにおいて極めて有効である

% 2.3 核言語

% 2.3.1 構文

% 2.3.2 値と型

% 2.3.3 基本型

% リスト
% リストはアトムnilであるか，タプル`|`(H T)である
% ここで，Tは束縛されていないかリストに束縛されている

% 2.3.4 レコードと手続き
% レコードはリスト，木，キューなどほとんどのデータ構造の基本要素である
% 言語がレコードを支援する仕方の上手下手によって，さらなる威力を発揮する

% レコードを扱う操作の例
% フィールドを追加，削除，選択，またリストへ，リストからの変換
% このレベルでレコードを支援する言語を記号的言語という

% 2.4 核言語の意味
% 静的スコープ対動的スコープ
% 静的スコープ プログラムのある場所に現れている識別子に対応する変数はその流れを取り囲む，もっとも内側の宣言で定義された変数である
% 動的スコープ プログラム中のある場所に現れている識別子に対応する変数は，その流れを含む文の実行に至るまでに，最も間近に実行された宣言で定義された変数である

% はじめのLisp言語は動的スコープであったが，common listやschemeは静的スコープである
% どちらがデフォルトなのが正しいのだろうか
% 静的スコープが正しい
% ある手続きが定義されたときに稼働中の手続きは，それが呼ばれた時の環境に無関係に稼働を続ける
% これは重要なソフトウェアエンジニアリング的性質である

% 2.4.2 抽象マシン

% 2.5 メモリ管理

% メモリの振る舞いを見る
% 計算の進行とともに，意味スタックと格納域の大きさがどのように変化するか見てみよう．
% 末尾呼び出し最適化の原理に触れ，それを抽象マシンを使って説明する．
% それによって，メモリライフサイクルとガーベッジコレクションに導かれる．

% 2.5.1 末尾呼び出し最適化

% 2.5.2 メモリライフサイクル
% 抽象マシンの意味から，実行可能プログラムに取って必要なのは，意味スタック上の情報と，意味スタックから到達可能な格納域の部分だけだ．
% 意味スタックと，格納域の到達可能な部分を併せてアクティブメモリと呼ぶ．

% 2.6 核言語から実用的言語へ

% 2.7 例外

% 宣言的モデルの範疇では，プオrグラムの至るところでチェックしなければ対処できない
% 例外処理を都和得ることで，もっとエレガントに対処する

% 2.7.1 動機と基本概念

% 2.4.4で，ある文が正しく実行できないときに，エラーを発生するといった．
% エラーとは，プログラムが意図する振る舞いと実際の振る舞いとの差であると定義する

% エラーが発生したら，例外ハンドラに実行を移して，エラーの種類を表す値を渡す

% エラーの波及を防いで，プログラム全体を汚染しないようにする
% エラー局限原則

% 例外処理機構によって，コンポーネント内部からその境界にジャンプする．このジャンプは単一操作である

declare
fun {Eval E}
   if {IsNumber E} then E
   else
      case E
      of plus(X Y) then {Eval X} + {Eval Y}
      [] times(X Y) then {Eval X} * {Eval Y}
      else raise illFormedExpr(E) end
      end
   end
end

% try
   {Browse {Eval plus(plus(5 5) 10)}}
   {Browse {Eval times(6 11)}}
   {Browse {Eval minus(7 10)}}
% catch illFormedExpr(E) then
%   {Browse '*** Illegal expression '#E#' ***'}
%end

% 2.7.2 例外を持つ宣言的モデル

% try 文
% raise 文
% catch 文

% 2.7.3 親言語の構文

% finnaly 節

% try <s1> finally <s2> end

/*
try
   <s1>
catch x then
   <s2>
   raise X end
end
<s2>
*/

% パターンマッチング

/*
try s catch p1 then s1
   [] p2 then s2
   ...
   [] pn then sn
end
*/

/*
try s catch X then
   case X
   of p1 then s1
   [] p2 then s2
      ...
   [] pn then sn
   else raise X end
   end
end
*/

% 2.7.4 システム例外

% failure つじつまの合わない束縛操作が行われたことを示す 単一化失敗とも呼ばれる

% error プログラム実行時のエラー 型か定義域のどちらかの誤り

% system Mozartオペレーティングシステムの環境内で実行時エラーが起こったことを示す．

% 2.8 進んだ話題

% 2.8.1 関数型プログラミング言語

% 数学的な意味における関数が，計算するための唯一の方法であるような言語を純粋関数型言語という．

% λ計算

declare
fun {IsNil X} x==nil end
declare
fun {IsCons X} case X of _|_ then true else false end end
declare
fun {Car H|T} H end
declare
fun {Cdr H|T} T end
declare
fun {Cons H T} H|T end

declare
Append = fun {$ Xs Ys}
	    if {IsNil Xs} then Ys
	    else {Cons {Car Xs} {Append {Cdr Xs} Ys}}
	    end
	 end

% append = λxs,ys . if isNil(xs) then ys
% 		  else cons(car(xs), append(cdr(xs), ys))

% 宣言的モデルを制限すること

% 宣言的モデルの構文に2つの制限をおいて，常に完全値について関数を計算するようにすることにより，
% 純粋関数型言語を定義できる．

% 線数を宣言するとき，ただちに値に束縛する．
% すなわち，local文は必ず次の2つのうちのどちらかにする．

% local <x>=<v> in <s> end
% local <x>={<y> <y1> ... <yn> } in <s> end

% 手続きでなく関数だけを使う．
% データ構造中の関数呼び出しについては，データ構造を生成する前に入れ子の呼び出しを行う．

% 関数型プログラミングの変種

% この章の関数型モデルは動的型付けである

% データフロー変数と単一代入格納域のおかげで大抵の関数型言語にないプログラミング技法がこの宣言的モデルには許される．
% ある種の末尾呼び出し最適化と3章に示した部分値についての計算がある

% 第4章の宣言的並列モデルにより，関数的プログラミングの好ましい性質を保ちながら，並列性が追加される．

% 宣言的モデルにおいて，関数はデフォルトとして性急である．

% 多くの関数型言語はカリー化という高階プログラミング技法を備えている．

% 2.8.2 単一化と内含（ないがん entailment）

% ある変数がある値に等しいかどうかテストすることは，内包チェックおよび反駁（はんはく）チェックの特殊な場合である.
% 2.8.2.1 単一化（＝操作）

% 単一化を概念化する良い方法は，単一代入格納域に情報を追加する操作とかんがえることである．

% 2.8.2.2 単一化のアルゴリズム

% 単一化を正確に定義しよう．
% unify(x, y)を2つの部分値xとyを格納域σの中で単一化する操作と定義する
% 単一化は論理型プログラミングにおける基本操作である

% 格納域変数を単一化の文脈で使うときは，論理変数（logic variable）という．
% 論理型プログラミングは関係プログラミングともいわれ，第九章で検討する

% 格納域
% 原始的束縛操作
% 格納域σ上の原始的束縛操作によって単一化を定義する．この操作は，ある同地集合の中のすべての変数を束縛する

% bind(ES, <vs>)は同値集合ESの中のすべての変数に数またはレコード<v>を束縛する
% 例えば，bind({x7, x8}, foo(a:x2))は，上の例の格納域を変更し，x7,x8を同値集合体してfoo(a:x2)に束縛する

% bind(ES1,ES2)は，同値集合ES1と同値集合ES2を併合する．
% 例えば，bind({x3,x4,x5},{x6})により，上の格納域を変更し，x3,x4,x5,x6を一つの同値集合{x3,x4,x5,x6}にする

% アルゴリズム
% 操作unify(x,y)を次のように定義する
% 1. xが同値集合ESxに属し，yが同値集合ESyに属するとするすれば，bind(ESx,ESy)が行われる．
% ESxとESyが同じ集合であれば，何も行われない．
% 2. xが同値集合ESxに属し，yが決定状態にあればbind(ESx, y)が行われる
% 3. yが同値集合ESyに属し，xが決定状態にあれば，bind(ESy, x)が行われる．
% 4. xがl(l1:x1,...ln:xn)に束縛されyがl'(l'1:y1,...l'm:ym)に束縛されていて，l≠l'または{l1,..ln}≠{l'1,...l'm}であればfalure例外が発生する
% 5. xがlに束縛され，yがl'に束縛されていれば，1からnまでのiについてunify(xi, yi)が行われる．

% 循環的構造の扱い
% 循環構造を持っている場合，無限ループになる．
% 同じ組み合わせの再度の呼び出しはなにもしないようにする
% メモ化表（memoization table)

% 2.8.2.3 循環的構造の表示
{Browse 1}

local X Y Z in
   f(X b) = f(a Y)
   f(Z a) = Z
   {Browse [X Y Z]}
end

declare X Y Z in
a(X c(Z) Z) = a(b(Y) Y d(X))
{Browse X#Y#Z}

% 2.8.2.4 内含チェックと反駁チェック (==操作と\=操作）

% 内含チェック X==Yはブール型関数で，XとYが等しいかどうかテストする．
% 逆のチェックX\=Yは反駁チェックと言われる．

% 対応する対の，異なるノードに対して，少なくとも一方が束縛されていないとき，ブロックする．

declare L1 L2 L3 Head Tail in
L1=Head|Tail
Head=1
Tail=2|nil
L2=[1 2]
{Browse L1==L2}
L3 = '|'(1:1 2:'|'(2 nil))
{Browse L1==L3}

declare L1 L2 X in
L1=[1]
L2=[X]
{Browse L1==L2}

declare L1 L2 X in
L1=[X]
L2=[X]
{Browse L1==L2}

declare L1 L2 X in
L1=[1 a]
L2=[X b]
{Browse L1==L2}

% 2.8.3 動的型付けと静的型付け

% 可能性の限界を見つける唯一の方法は，敢えて不可能性の方へちょっと踏み出してみることだ．

% 言語は強く型付けされていることが重要である．
% 